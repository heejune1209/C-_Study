namespace Array
{
    internal class Program
    {
        // 배열
        // 크기는 한번 선언하면 바꿀 수 없다.
        // 배열 크기를 벗어나는 인덱스로 배열에 접근하면 런타임 에러가 발생한다.

        // C#에서 배열은 "참조 타입"이다.
        // 즉, 배열 변수는 "배열의 데이터가 저장된 힙 메모리의 주소"를 가지고 있는** 참조(reference)**이다.

        static void ReplaceArray(ref int[] arr)
        {
            arr = new int[] { 9, 9, 9 };  // 새로운 배열을 참조하게 만듦
            // 만약 매개변수에 ref를 빼면, arr = new int[] { 9, 9, 9 }; 이 코드는 복사된 참조를 바꾼 것이라 바깥에 영향 없음
            // array == [1, 2, 3] (변경 안 됨)
            // 만약 ref를 안쓰고 변경하고 싶다면, 배열을 리턴해서 바깥 배열을 바꾸면 된다.
        }
        static int[] ReplaceArray(int[] arr)
        {
            arr = new int[] { 9, 9, 9 };  // 새로운 배열을 만든다
            return arr;                  // 그걸 리턴해준다
        }


        static void Main(string[] args)
        {
            int[] array = new int[5];
            array[0] = 10;
            array[1] = 20;
            array[2] = 30;
            array[3] = 40;
            array[4] = 50;
            // 동일한 자료형을 가진 데이터들을 연속적인 메모리로 저장하여 인덱스로 접근할 수 있게 된다.
            int[] array2 = new int[] { 10, 20, 30 }; // 이렇게도 표현할수 있다
            int[] array3 = new int[5] { 10, 20, 30, 40, 50 }; // 5개를 할당했으니 5개를 넣어줘야한다.
            // new 키워드를 사용하여 동적으로 할당 받는 배열을 만들 수 있다. (동적으로 할당 받았다고해서 동적 배열인 것은 아님.
            // 동적 배열은 크기가 가변적인 배열을 의미. 동적으로 할당, 즉 힙 메모리에 할당 받았을 뿐 크기를 바꿀 수 없는 정적 배열이다.)
            // 배열을 동적으로 할당 받으므로(배열 데이터가 힙메모리에 있으므로) 동일한 배열 메모리를 가리키는 변수가 여러개일 수도 있다. 👉 Call by Reference
            
            int[] array4 = { 10, 20, 30 };
            int[] array5 = array;
            // new를 생략하는 것도 가능하다. 그래도 두 변수가 동일한 배열 메모리를 가리킬 수 있는 것을 보면 동적으로 할당(힙 메모리로) 받는 것 같다.
            // C#은 C++과 달리 배열이 무조건 힙 메모리에 존재하게 되어 있다. 즉 무조건 동적으로 할당 받음.

            // [array]─┐
            //        ├──> [100, 0, 0](힙에 있는 배열)
            // [array5]─┘
            // 두 참조 변수는 같은 배열을 가리키므로, 하나로 수정하면 나머지에도 영향을 줌.
            // 이게 바로 **"참조 타입" * *이기 때문에 가능한 일.

            //--------------------------------------------
            // C++과 C#의 배열 차이

            // 1. 선언 방식
            // C++ ver
            //int arr[3] = { 1, 2, 3 };  // 스택에 할당됨
            //arr[0] = 10;

            // C# ver
            // int[] arr = new int[] { 1, 2, 3 };  // 힙에 할당됨
            // arr[0] = 10;

            // 2. 메모리 위치
            // c++은 보통 스택(또는 new 사용 시 힙)
            // C#은 무조건 힙 (new 사용 시)

            // 3. 타입
            // c++은 값타입,(포인터처럼 동작) , c#은 참조 타입

            // 4. 범위 검사
            // c++은 범위검사가 없고, c#은 있다

            // 5. 배열은 객체인가?
            // c++에선 기본 배열은 객체 아님. 포인터에 가까움
            // C#에선 int[] 자체가 클래스 객체 (System.Array의 인스턴스)

            // 6. 매개변수로 배열을 받으면?
            // c++에선 배열을 함수의 매개변수로 넘기면 사실상 포인터처럼 동작하고, C#에서는 배열이 참조 타입이기 때문에, 함수에 넘기면 참조(주소)가 복사되어 원본 배열에 접근할 수 있어.

            // C++에서 배열을 함수에 넘기면?
            // 여기서 int arr[]는 사실 int* arr와 동일해.
            // 즉, 함수 내부에서는 포인터로 처리되고, 배열 이름이 배열의 첫 번째 요소의 주소가 돼.

            // C#에서 배열을 함수에 넘기면?
            // C#에서는 배열이 참조 타입이라서, arr라는 변수는 힙에 있는 배열을 가리키는 참조를 가지고 있고,
            // 함수에 넘기면 **그 참조(주소) * *가 복사돼서 함수 안에서도 같은 배열을 건드릴 수 있는 거야

            // Q : c#에서 배열은 참조타입으로 동작하는데 ref를 같이 쓸 이유가 없지 않나?
            // A : 배열의 값을 수정할땐 ref가 필요없는데, 배열을 다른 배열로 교체할땐 필요함.
            // 즉, 배열의 "참조 대상" 자체를 바꾸고 싶으면 ref가 필요함.
            int[] array6 = new int[] { 1, 2, 3 };
            ReplaceArray(ref array6);
            // array == [9, 9, 9]

            int[] myArray = new int[] { 1, 2, 3 };
            myArray = ReplaceArray(myArray);  // ⭐ 리턴값을 다시 myArray에 할당해야 반영됨, (ref 없이 배열을 리턴해서 바깥 배열을 바꾸는 ver)

            //-------------------------------
            // foreach문
            foreach (var element in array)
                Console.WriteLine(element);
            // 특정 자료구조 ‘전체’를 뺑뺑 순회할거면 foreach문을 사용하는 것이 좋다. 가독성을 높일 수 있고 인덱스 실수할 일도 없다.
        }
    }
}
